<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
    <!-- Use title if it's in the page YAML frontmatter -->
    <title>Page Title</title>
    <link href="../../../../stylesheets/normalize.css" rel="stylesheet" type="text/css" /><link href="../../../../stylesheets/all.css" rel="stylesheet" type="text/css" />
    <link href='http://fonts.googleapis.com/css?family=Advent+Pro' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Roboto:100' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:200' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <div class='header'>
      <h1 class='header-text'>TIER LIST OF THE STORM</h1>
    </div>
    <div class='content'>
      <p>The main API into react router. It runs your routes, matching them
      against a location, and then calls back with the next state for you to
      render.</p>
      
      <h2 id="signature">Signature</h2>
      
      <p><code>Router.run(routes, [location,] callback)</code></p>
      
      <h2 id="arguments">Arguments</h2>
      
      <h3 id="routes"><code>routes</code></h3>
      
      <p>Your route config. See <a href="#TODO">Route</a></p>
      
      <h3 id="location-optional"><code>location</code> optional</h3>
      
      <p>Defaults to <code>Router.HashLocation</code>. If given a <code>Location</code> object, it
      will setup and listen for changes on it, if given a string path, the
      router will immediately match that path and callback.</p>
      
      <h4 id="examples">Examples</h4>
      
      <p>```js
      // Defaults to <code>Router.HashLocation</code>
      // callback is called whenever the hash changes
      Router.run(routes, callback);</p>
      
      <p>// HTML5 History
      // callback is called when history events happen
      Router.run(routes, Router.HistoryLocation, callback);</p>
      
      <p>// Server rendering
      // callback is called once, immediately.
      Router.run(routes, '/some/path', callback);
      ```</p>
      
      <h3 id="callbackroot-state"><code>callback(Root, state)</code></h3>
      
      <p>The callback receives two arguments:</p>
      
      <ol>
        <li><code>Root</code></li>
        <li><code>state</code></li>
      </ol>
      
      <h4 id="root"><code>Root</code></h4>
      
      <p>A ReactComponent class with the current match all wrapped up inside it, ready
      for you to render.</p>
      
      <h4 id="state"><code>state</code></h4>
      
      <p>An object containing the matched state.</p>
      
      <h4 id="statepath"><code>state.path</code></h4>
      
      <p>The current URL path with query string.</p>
      
      <h4 id="stateaction"><code>state.action</code></h4>
      
      <p>The action that lead to the route change.</p>
      
      <h4 id="statepathname"><code>state.pathname</code></h4>
      
      <p>The current URL path without the query string.</p>
      
      <h4 id="stateparams"><code>state.params</code></h4>
      
      <p>The active params in the location match.</p>
      
      <h4 id="statequery"><code>state.query</code></h4>
      
      <p>The active query in the location match.</p>
      
      <h4 id="stateroutes"><code>state.routes</code></h4>
      
      <p>An array of the matched <a href="#TODO">routes</a>. Very useful for fetching data before
      rendering.</p>
      
      <p>See also: <a href="#TODO">Route</a>.</p>
      
      <h2 id="examples-1">Examples</h2>
      
      <p>Basic Usage:</p>
      
      <p><code>js
      Router.run(routes, function (Root) {
        // whenever the url changes, this callback is called again
        React.render(&lt;Root/&gt;, document.body);
      });
      </code></p>
      
      <p>Sample data fetching using <code>state.routes</code>. Check out the
      <a href="#TODO">async-data</a> example.</p>
      
      <p>```js
      var resolveHash = require('when/keys').all;</p>
      
      <p>var SampleHandler = React.createClass({
        statics: {
          // this is going to be called in the <code>run</code> callback
          fetchData: function (params) {
            return fetchStuff(params);
          }
        },
        // â€¦
      });</p>
      
      <p>Router.run(routes, Router.HistoryLocation, function (Root, state) {</p>
      
      <p>// create the promises hash
        var promises = state.routes.filter(function (route) {
          // gather up the handlers that have a static <code>fetchData</code> method
          return route.handler.fetchData;
        }).reduce(function (promises, route) {
          // reduce to a hash of <code>key:promise</code>
          promises[route.name] = route.handler.fetchData(state.params);
          return promises;
        }, {});</p>
      
      <p>resolveHash(promises).then(function (data) {
          // wait until we have data to render, the old screen stays up until
          // we render
          React.render(&lt;Root data={data}/&gt;, document.body);
        });
      });
      ```</p>
      
      <p>Server Rendering</p>
      
      <p><code>js
      something.serve(function (req, res) {
        Router.run(routes, req.path, function (Root, state) {
          // could fetch data like in the previous example
          fetchData(state.matches).then(function (data) {
            var html = React.renderToString(&lt;Root data={data} /&gt;);
            res.send(html);
          });
        });
      });
      </code></p>
    </div>
    <div class='footer'>
      @keikun17
    </div>
  </body>
  <script src="../../../../javascripts/all.js" type="text/javascript"></script>
</html>
